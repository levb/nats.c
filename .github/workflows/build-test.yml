name: build and test
on:
  workflow_call:
    inputs:
      arch:
        type: string
        default: "64"
      compiler:
        type: string
        default: "gcc"
      coverage:
        type: string
        default: "OFF"
      lib_msg_delivery:
        type: string
        default: "OFF"
      lib_write_deadline:
        type: string
        default: "OFF"
      quick_test:
        type: string
        default: "OFF"
      sanitize:
        type: string
        description: "sanitize option to use, 'address' or 'thread'"
      server_version:
        type: string
        description: "nats-server version to test with"
        default: "latest"
      streaming:
        type: string
        default: "ON"
      tls:
        type: string
        default: "ON"
      type:
        type: string
        description: "Debug or Release."
        default: "Release"
      ubuntu_version:
        type: string
        description: "Ubuntu version to use, e.g. '20.04'"
        default: "latest"

defaults:
  run:
    shell: bash --noprofile --norc -x -eo pipefail {0}

jobs:
  build-test:
    runs-on: ubuntu-${{ inputs.ubuntu_version }}
    name: build and test on Ubuntu
    steps:
      - name: Checkout nats.c
        uses: actions/checkout@v3

      # configure the unique build artifact name
      - id: configure-artifact
        name: Configure unique build artifact name
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          unique="-ubuntu-${{ inputs.ubuntu_version }}"
          unique="${unique}-${{ inputs.type }}"
          unique="${unique}-${{ inputs.compiler }}"
          unique="${unique}-${{ inputs.arch }}"
          unique="${unique}-tls${{ inputs.tls }}"
          unique="${unique}-streaming${{ inputs.streaming }}"
          if [[ -n "${{ inputs.sanitize }}" ]]; then
            unique="${unique}-${{ inputs.sanitize }}"
          fi
          if [[ "${{ inputs.lib_msg_delivery }}" == "ON" ]]; then
            unique="{$unique}-msg-delivery"
          fi
          if [[ "${{ inputs.lib_write_deadline }}" == "ON" ]]; then
            unique="{$unique}-write-deadline"
          fi
          echo "name=build${unique}.tar.gz" >> $GITHUB_OUTPUT

      # configure the cmake flags and NATS_... environment variables
      - id: cmake-flags
        name: Configure cmake flags
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          flags="-DNATS_BUILD_ARCH=${{ inputs.arch }} -DCMAKE_BUILD_TYPE=${{ inputs.type }}"
          if [[ -n "${{ inputs.sanitize }}" ]]; then
            flags="$flags -DNATS_SANITIZE=ON -DCMAKE_C_FLAGS=-fsanitize=${{ inputs.sanitize }}"
          fi
          flags="$flags -DNATS_BUILD_STREAMING=${{ inputs.streaming }}"
          flags="$flags -DNATS_BUILD_WITH_TLS=${{ inputs.tls }}"
          echo "flags=$flags" >> $GITHUB_OUTPUT

      - id: nats-vars
        name: Configure NATS_ environment variables
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          if [[ -n "${{ inputs.sanitize }}" ]]; then
            echo "NATS_TEST_VALGRIND=yes" >> $GITHUB_ENV
          fi
          if [[ "${{ inputs.lib_msg_delivery }}" == "ON" ]]; then
            echo "NATS_DEFAULT_TO_LIB_MSG_DELIVERY=yes" >> $GITHUB_ENV
          fi
          if [[ "${{ inputs.lib_write_deadline }}" == "ON" ]]; then
            echo "NATS_DEFAULT_LIB_WRITE_DEADLINE=2000" >> $GITHUB_ENV
          fi

      # install build dependencies
      - name: Install ${{ inputs.compiler }} if needed
        if: startsWith(inputs.compiler, 'clang-') || startsWith(inputs.compiler, 'gcc-')
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          sudo apt-get -q update
          sudo apt-get -y install ${{ inputs.compiler }}

      - name: Install libprotobuf-c and prepare to compile with ${{ inputs.compiler }}
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          sudo apt-get -q update
          sudo apt-get -y install libprotobuf-c-dev
          echo "CC=${{ inputs.compiler }}" >> $GITHUB_ENV

      # if we have already built, unarchive and no need to configure/build with
      # cmake
      - name: Download previous build artifact
        id: download-prior-build
        continue-on-error: true
        uses: actions/download-artifact@v3
        with:
          name: ${{ steps.configure-artifact.outputs.name }}
          path: .

      - name: Unarchive build artifact
        if: steps.download-prior-build.outcome == 'success'
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: tar -xzf build.tar.gz

      # otherwise, configure cmake, build, archive and upload
      - name: CMake
        if: steps.download-prior-build.outcome != 'success'
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          mkdir -p build
          cd build
          cmake .. ${{ steps.cmake-flags.outputs.flags }}
          make rebuild_cache && make
          cd ..
          tar -czf build.tar.gz build

      - name: "Rebuild the list of tests to match the compile flags"
        if: steps.download-prior-build.outcome != 'success'
        shell: bash --noprofile --norc -x -eo pipefail {0}
        working-directory: ./build
        run: |
          ./test/testsuite
          if [[ $(diff list.txt ../test/list.txt; echo $?) != 0 ]]; then
            mv list.txt ../test/list.txt
            make rebuild_cache
          fi

      - name: Archive build artifact
        if: steps.download-prior-build.outcome != 'success'
        shell: bash --noprofile --norc -x -eo pipefail {0}
        run: |
          tar -czvf build.tar.gz build

      - name: Upload build artifact
        if: steps.download-prior-build.outcome != 'success'
        uses: actions/upload-artifact@v3
        with:
          name: ${{ steps.configure-artifact.outputs.name }}
          path: build.tar.gz

      # testing

      - name: "Checkout test dependencies (nats.c.deps)"
        uses: actions/checkout@v3
        with:
          repository: nats-io/nats.c.deps
          path: build/deps

      - name: "Download nats-server version ${{ inputs.server_version }}"
        if: inputs.quick_test != 'ON' && !inputs.server_version
        shell: bash --noprofile --norc -x -eo pipefail {0}
        working-directory: ./build
        run: |
          if [[ "${{ inputs.server_version }}" == "latest" ]]; then
            rel=$(curl -s https://api.github.com/repos/nats-io/nats-server/releases/latest | jq -r '.tag_name')
          else
            rel=${{ inputs.server_version }}
          fi
          wget https://github.com/nats-io/nats-server/releases/download/${rel}/nats-server-${rel}-linux-amd64.tar.gz
          if [[ $? == 0 ]]; then
            tar -xzf nats-server-${rel}-linux-amd64.tar.gz
            cp nats-server-${rel}-linux-amd64/nats-server ../deps/nats-server
          else
            curl -sf 'https://binaries.nats.dev/nats-io/nats-server/v2?os=linux&arch=amd64&version=${{ inputs.server_version }}'' | PREFIX=. sh
            mv ./nats-server ./deps/nats-server
          fi

      - name: "Install coverage"
        shell: bash --noprofile --norc -x -eo pipefail {0}
        if: inputs.quick_test != 'ON' && inputs.coverage
        run: |
          pip install --user cpp-coveralls

      - name: "Test"
        shell: bash --noprofile --norc -x -eo pipefail {0}
        working-directory: ./build
        run: |
          export PATH=$(pwd)/deps/nats-server:$(pwd)/deps/nats-streaming-server:$PATH
          export NATS_TEST_SERVER_VERSION="$(nats-server -v)"
          if [[ "${{ inputs.quick_test }}" == "ON" ]]; then
            ctest --timeout 60 --output-on-failure -I1,1
          else
            ctest --timeout 60 --output-on-failure 2>&1 | tee /tmp/out.txt
            if [[ $(grep -q 'WARNING: ThreadSanitizer: ' /tmp/out.txt; echo $?) == 0 ]]; then
              echo "!!! ThreadSanitizer detected WARNING(s) !!!"
              exit 1
            fi
          fi
